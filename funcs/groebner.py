"""
This file will contain the coe implementation of hilbert-driven
Buchberger algorithm to compute the groebner basis of a set of 
homogeneous polynomials
"""

from math import lcm
from func_utils import *
from hilbert import *

def HP_buch(W, F, hp, gens):
    """
    This is algorithm 1.2.19 from Gatermann that adapts 
    Buchberger algorithm to a single grading W, driven by hilbert
    poincare series hp, and computes the Groebner basis of a set 
    of W-homogeneous polynomials F. 
    
    Inputs:
    W: Single grading W forming a weight system
    F: List of dictionaries ((power tuple): coefficient) that defines a polynomial is Sympy class
    hp: Hilbert poincare series of K[x]/I
    gens: Sympy symbols for the polynomial ring K[x]

    Output:
    GB: Groebner basis of I generated by F
    """
    # Initialise variables
    F_poly = [sy.polys.Poly.from_dict(i, gens) for i in F] 
    GB = F_poly
    m = len(F)
    HT = [leading_term(W, sy.polys.Poly.from_dict(i, gens)) for i in F] # power tuples of ht(f_i)
    HThc = {ht: F[i].get(ht) for ht in HT for i in range(m)} # power tuple: leading coeff of f_i
    HP = hilbert(HT, W, gens)
    # no.missing polynomials of deg d
    # Note that Sympy .all_coeffs() only works for univariate polynomials
    # Here I am taking advantage of only using a single grading - HP and hp are univariate. 
    coeff_diff = (HP - hp).all_coeff()[::-1]
    # Choose the smallest power (min i)
    d = next((i for i, x in enumerate(coeff_diff) if x != 0), None)
    cd = coeff_diff[d]
    # Define the set of indicies S
    HT_lcm = {(i,j) : weighted_deg(W, tup_lcm(HT[i], HT[j])) for i in range(m) for j in range(m)}
    S = [key for key, item in HT_lcm if item >= d]
    while len(S) > 0:
        ind_pair = S.pop(0)
        fi = F_poly[ind_pair[0]]
        fj = F_poly[ind_pair[1]]
        # Compute S-polynomial and normal form of S-polynomial
        s_ij = S_poly(fi, fj, W, gens)
        g = normalf(W, GB, s_ij)
        if g != sy.Poly(0.0, gens):
            GB.append(g)
            g_dict = g.as_dict()
            g_ht = leading_term(W, g, gens)
            HT.append(g_ht)
            HThc.update({g_ht:g_dict.get(g_ht)})
            m += 1
            cd -= 1
            if cd == 0:
                HP = hilbert(HT, W, gens)
                if HP == hp:
                    return GB # GB found
                # Here I am taking advantage of only using a single grading - HP and hp are univariate. 
                coeff_diff = (HP - hp).all_coeff()[::-1]
                # Choose the smallest power (min i)
                d = next((i for i, x in enumerate(coeff_diff) if x != 0), None)
                cd = coeff_diff[d]
                S = [p for p in S if weighted_deg(W,leading_term(W, S_poly(F_poly[p[0]], F_poly[p[1]], W, gens), gens)) >= d]
            S_im = {(i,m): weighted_deg(W, leading_term(W, F_poly[i], F_poly[m], W, gens)) for i in range(m)}
            S = S + [key for key, item in S_im if item >= d]
    return GB


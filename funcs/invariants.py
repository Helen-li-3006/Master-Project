""" 
This file will contain the function to compute the Groebner basis 
of the invariant ring using the algorithm 2.1.10 presented in 
Gatermann's paper
"""

from funcs.func_utils import *
from funcs.hilbert import *
from groebner2 import *
import sympy as sy
import numpy as np

from itertools import combinations_with_replacement, combinations

def mn_comb(m,n,lis=None):
    """
    Generates all possible combinations of m numbers that sums up to n
    """
    if lis:
        combs = []
        for c in combinations_with_replacement(lis, m):
            if sum(c) == n:
                combs.append(c)
    else:
        combs = []
        for c in combinations_with_replacement(range(n+1), m):
            if sum(c) == n:
                combs.append(c)
    return combs

def M_subs(poly, x_symbols, expressions):
    """
    Function to replace y_i in poly as ht(p_i)
    Inputs:
    poly: sympy expression of a polynomial
    x_symbols: original variables for the expressionn
    expressions: ht(p_i) that is substituted into polynomial
    """
    subspoly = poly.as_expr()
    for term, ht in zip(x_symbols, expressions):
        subs_poly = subs_poly.subs(term, ht)
    subs_poly = sy.expand(subs_poly)
    return subs_poly

vec_M_subs = np.vectorize(M_subs, excluded=['x_symbols' ,'expressions'])

def tup_mon(tup, syms):
    """
    Converts the power tupe into a monomial given symbols
    """
    expression = 1.0
    for i in range(len(tup)):
        expression *= syms[i]**tup[i]
    return expression

vec_tup_mon = np.vectorize(tup_mon, excluded=['syms'])

def reynold(poly, G, syms):
    """
    Computes the Reynold projection of polynomial under actions of finite group G
    
    Inputs:
    poly: sympy expression 
    G: finite group with matrix representation
    syms: sympy variables for poly
    """
    rey = 0
    # Compute the replaced expressions
    for g in G:
        expressions = tuple(g * sy.Matrix(syms))
        subs_poly = M_subs(poly, syms, expressions)
        rey += subs_poly
    return (1/len(G))*rey

vec_reynold = np.vectorize(reynold, excluded=['G', 'syms'])

def inv_ring(G, mol, t, x, W, d):
    """
    Implementation of algorithm 2.1.10 for finite groups

    Inputs:
    G: A finite group under matrix representation, a list of Sympy matrices
    mol: Molien series of the finite group G
    t: sympy symbol (variable) for Molien series
    x: sympy symbols (variables) of the polynomial ring K[x]
    W: Weight system that induces a term order (which is an elimination order), Sympy matrix
    d: Maximal degree to compute invariants up to
    """
    # Initialisation
    invs = [] # set of invariants
    m = 0 # no. of invariants found
    GB = [] # Groebner basis for the invariant ring
    HT = [] # set of leading terms of GB - poly expressions
    mol = hilb_expand(mol, t, d)
    k = sy.poly(mol).as_dict()[min_deg(sy.poly(mol), t)]
    HP = 1 # Initialise the tentative Hilbert series for ideal generated by invariants
    N = sy.Matrix([[1]*len(x)]) # The natural grading for K[x_1, ..., x_n]
    while k <= d:
        y = sy.symbols('y:{}'.format(m))
        mol_hp_diff = mol - HP
        s = sy.poly(mol_hp_diff).as_dict()[min_deg(sy.poly(mol_hp_diff), t)]
        V = mn_comb(len(x), k) # This is a list of tuples
        V = vec_tup_mon(V, x)
        inv_degs = [weighted_deg(N,leading_term(N,inv,y)) for inv in invs]
        ind_W = sy.Matrix([inv_degs])
        all_y_comb = list(combinations(range(k+1), len(y)))
        y_comb = [c for c in all_y_comb if weighted_deg(W, c) == k] # This is a list of tuples
        M = vec_tup_mon(y_comb, y)
        M = vec_M_subs(M, y, HT)
        V = [mon for mon in V if mon not in M]
        Q = vec_reynold(V, G, x)
        P = []
        for i in range(len(Q)):
            h = normalf(W, GB, M[i], x+y)
            if not bool(h.free_symbols.intersection(y)):
                x_sub = [0.]*len(x)
                p = M[i] - vec_M_subs(h, x+y, x_sub + invs)
                p = normalf(W, P, p, x+y)
                if not p.is_zero:
                    P.append(p)
        invs.extend(P)
        mol_hp_diff = mol - HP
        k_list = list(sy.poly(mol_hp_diff, t).as_dict().keys())
        k = min([deg for deg in k_list if deg > k]) # This is the next degree for fundamental invariants
        if k > d:
            return invs
        # Extend the elimination oder to the extended invariants
        W = sy.Matrix([list(W) + [0]*len(y)])
        # Extend the y symbols to extended invariants
        y += [sy.symbols('y%d' % i) for i in range(m, m+len(P))]
        # Extend the leading terms of invariants
        HT.extend([leading_term(W, poly, y) for poly in invs])
        GB.extend([y[m+i] - P[i] for i in range(len(P))])
        hp, l = hilbert(HT, W, y)
        GB = dtrunc_groebner(W, 1, W, d, GB, hp, y, l, dom=None)
        m += len(P)
        mol_hp_diff = mol - HP
        k_list = list(sy.poly(mol_hp_diff, t).as_dict().keys())
        k = min(k_list)
        if k > d:
            return invs
    return invs




        

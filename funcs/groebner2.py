"""
This file contain the implementation of algorithm 1.2.23 from Gatermann's paper
that computes the multi-truncated Groebner basis w.t.r a multigrading. 
"""

"""
Double check the definition of space S and construction of the S set
"""

from faulthandler import cancel_dump_traceback_later
from math import lcm
from func_utils import *
from hilbert import *

def min_deg(poly, grading, gens):
    """
    Return the minimum degree (vector for multigrading) for a polynomial (hilbert function)
    with respect to grading
    
    Inputs:
    poly: Hilbert function as a polynomial
    grading: m x s sympy matrix representing a weight system corresponds to a (multi) grading

    Outputs: Power tuple of the minimal degree term w.r.t grading

    """
    pows = [key for key, item in poly]
    pows_inc = leading_term(grading, poly, gens, re_all = True)
    return pows_inc[-1] #return minimal power tuple

def compare_degs(deg1, deg2, W):
    """
    Return the boolean for deg1 <= deg2 (vector degrees frm multigrading) w.r.t term order 
    defined by weight system W

    Inputs:
    deg1, deg2: power tuples
    W : m x r Sympy matrix representing a term order
    """
    gens = sy.symbols('x_0:{}'.format(len(deg1)))
    poly = sy.polys.Poly.from_dict({deg1:1., deg2:1.}, )
    if deg1 == min_deg(poly, W, gens):
        return True
    return False

def equate_powers(deg1, deg2, W):
    return True if weighted_deg(deg1, W) == weighted_deg(deg2, W) else False

def update_hp(F_ht, W_sub, d, x):
    hp_ht, ls = hilbert(F_ht, W_sub, x) # Coef b_i in algorithm
    hp_ht = hilb_expand(hp_ht, ls, list(d))
    return hp_ht, ls

def update_Cdelta(hp_ht, hp_sub, U, ls):
    hp_diff = hp_ht - hp_sub
    delta = min_deg(hp_diff.as_dict(), U, ls)
    c_delta = hp_diff.as_dict()[delta]
    return delta, c_delta

def update_Depsilon(HP_diff, delta_r, W, l):
    # Find the set E of possible r-s degrees
    E = {key: 1.0 for key in HP_diff.as_dict().keys() if is_divisible(sy.polys.Poly.from_dict({key:1.0}, l), sy.polys.Poly.from_dict({delta_r:1.}, l), W, l)}
    delta_epsilon = min_deg(sy.polys.Poly.from_dict(E), W, l)
    D_epsilon = HP_diff.as_dict()[delta_epsilon]
    return delta_epsilon, D_epsilon, E

def get_slice_E(E, delta, W, S, F, x):
    slice_delta_E = []
    for e in E:
        delta_e = delta + tuple(e)
        slice_delta_e = [pair for pair in S if equate_powers(weighted_deg(W, leading_term(W, S_poly(F[pair[0]], F[pair[1]], W, x), x)), delta_e, W)]
        slice_delta_E.append(slice_delta_e)
    return slice_delta_E

def dtrunc_groebner(W, s, U, d, F, hp, x, l):
    """
    Implementation of algorithm 1.2.23 from Gaterman's paper
    that exploits the graded strucutre of the polynomial ring to 
    compute the d-truncated Groebner basis for the ideal generated by F
    with respect to a term ordering induced by weight matrix U

    Inputs:
    W: n x r (#col x #row) sympy matrix of a weight system
    s: minimal s such that W_1, ..., W_s is a valid weight system (subsystem of W)
    U: n x t Weight matrix that represents a set of grading, corresponds to a termm ordering
    d: t-length tuple that is the maximal degree for elements of the Groebner basis
    F: Set of m U,W homogeneous polynomials that generates an ideal I, list of Sympy polynomials
    hp: Hilbert series of graded module K[x]/I w.r.t W (coefficient c_i)
    x: Sympy symbols for variables in polynomial ring K[x]
    l: Sympy symbols for hp (l_1, ..., l_r)
    """
    # Initialisation 
    GB = F
    m = len(F)
    hp = hilb_expand(hp, l, list(d)) # Expand hilbert series up to truncated degree
    W_sub = W[:s, 0:] # Sub-system of W_1, ..., W_r
    F_dict = [pol.as_dict() for pol in F] # List of polynomials as power: coef
    F_ht = [leading_term(U, pol, x) for pol in F] # List of leading terms w.r.t U (term order)
    # Compute the tentative hilbert series and reduce hp to subsystem
    sub_dict = {l[i]:ls[i] for i in range(len(ls))}
    sub_dict.update({l[i]:1. for i in range(len(ls), len(l))})
    hp_sub = hp.subs(sub_dict) # Coef a_i in algorithm
    hp_ht, ls = update_hp(F_ht, W_sub, d, x)
    if hp_sub == hp_ht:
        return GB # no polynomial to find
    delta, c_delta = update_Cdelta(hp_ht, hp_sub, U, ls)
    delta_r = delta + tuple([0 for i in range(W.shape[0] - s)])
    if compare_degs(d, delta):
        return GB # no polynomials to find
    HP, l = update_hp(F_ht, W, d, x) # coef d_i in algorithm
    HP_diff = HP - hp
    delta_epsilon, D_epsilon, E = update_Depsilon(HP_diff, delta_r, W, l)
    # Define the set S of pairs of indices that corresponds to syzygies
    U_lcm = {(i,j) : weighted_deg(U, tup_lcm(F_ht[i], F_ht[j])) for j in range(m) for i in range(j)}
    W_lcm = {(i,j) : weighted_deg(W, tup_lcm(F_ht[i], F_ht[j])) for j in range(m) for i in range(j)}
    S = [key for key in W_lcm if compare_degs(U_lcm[key], d, U) and compare_degs(W_lcm[key], delta_epsilon, W)]
    if len(S) == 0:
        return GB
    delta_eps_S = [pair for pair in S if equate_powers(weighted_deg(W, leading_term(W, S_poly(F[pair[0]], F[pair[1]], W, x), x)), delta_epsilon, W)]
    if len(delta_eps_S) == 0:
        """
        Double check the logic of updating parameters - how and when are series updated?
        """
        # Update both hilbert series
        hp_ht, ls = update_hp(F_ht, W_sub, d, x)
        HP, l = update_hp(F_ht, W, d, x)
        # Update parameters
        delta, c_delta = update_Cdelta(hp_ht, hp_sub, U, ls)
        delta_r = delta + tuple([0 for i in range(W.shape[0] - s)])
        delta_epsilon, D_epsilon, E = update_Depsilon(HP, hp, delta_r, W, l)
    while len(S) > 0:
        # Get slice where deg_U <= d and deg_W = delta_epsilon
        slice = [pair for pair in delta_eps_S if compare_degs(leading_term(U, S_poly(F[pair[0]], F[pair[1]], U, x), x), d, U)]
        pair = slice.pop()
        S.remove(pair)
        g = normalf(U, GB, S_poly(F[pair[0]], F[pair[1]], U, x))
        if g != sy.Poly(0.0, x):
            GB.append(g)
            F_ht.append(leading_term(U, g, x))
            m += 1
            c_delta -= 1
            D_epsilon -= 1
            S_im_slice = [(i,m) for i in range(m) if 
                          compare_degs(leading_term(U, S_poly(F[i], F[m], U, x), x), d, U) and 
                          compare_degs(delta_epsilon, leading_term(W, S_poly(F[i], F[m], W, x), x), W)]
            if D_epsilon == 0:
                E.remove(delta_epsilon[s:])
                S_delta_E_slice = get_slice_E(E, delta, W, S, F, x)
                if len(E) == 0 or len(S_delta_E_slice) == 0:
                    hp_ht, ls = update_hp(F_ht, W_sub, d, x)
                    HP, l = update_hp(F_ht, W, d, x)
                    HP_diff = HP - hp
                    delta, c_delta = update_Cdelta(hp_ht, hp_sub, U, ls, s, W.shape[0])
                    delta_r = delta + tuple([0 for i in range(W.shape[0] - s)])
                    delta_epsilon, D_epsilon, E = update_Depsilon(HP_diff, delta_r, W, l)
                    S = [pair for pair in S if compare_degs(delta_epsilon, leading_term(W, S_poly(F[pair[0]], F[pair[1]], W, x), x), W)]
                delta_epsilon = min_deg(sy.polys.Poly.from_dict(E), W, l)
                D_epsilon = HP_diff.as_dict()[delta_epsilon]
                S = [pair for pair in S if compare_degs(delta_epsilon, leading_term(W, S_poly(F[pair[0]], F[pair[1]], W, x), x), W)]
            if c_delta == 0:
                hp_ht, ls = update_hp(F_ht, W_sub, d, x)
                HP, l = update_hp(F_ht, W, d, x)
                HP_diff = HP - hp
                delta, c_delta = update_Cdelta(hp_ht, hp_sub, U, ls, s, W.shape[0])
                delta_r = delta + tuple([0 for i in range(W.shape[0] - s)])
                delta_epsilon, D_epsilon, E = update_Depsilon(HP_diff, delta_r, W, l)
                S = [pair for pair in S if compare_degs(delta_epsilon, leading_term(W, S_poly(F[pair[0]], F[pair[1]], W, x), x), W)]
    return GB






